import apiClient from '@/api/apiClient';
import type { LlmAgentConfig, AgentSummaryDTO as SharedAgentSummaryDTO } from '@/types/agents';
import type { ToolDTO, UiToolDefinition as SharedUiToolDefinition } from '@/types/tools';

/**
 * API payload for creating an agent. Excludes fields generated by the backend (id, timestamps, user_id)
 * and uses ToolDTO[] for tools, as the backend expects full tool definitions for creation/association.
 */
export interface CreateAgentAPIPayload extends Omit<LlmAgentConfig, 'id' | 'created_at' | 'updated_at' | 'user_id' | 'tools'> {
  tools: ToolDTO[];
  knowledge_base_ids?: string[];
}

/**
 * API payload for updating an agent. All fields are partial.
 */
export type UpdateAgentAPIPayload = Partial<CreateAgentAPIPayload>;

/**
 * Fetches a list of all agents (summary view).
 */
export const fetchAgents = async (): Promise<SharedAgentSummaryDTO[]> => {
  const { data } = await apiClient.get<SharedAgentSummaryDTO[]>('/agents');
  return data;
};

/**
 * Fetches the detailed configuration of a single agent by its ID.
 */
export const fetchAgentById = async (id: string): Promise<LlmAgentConfig> => {
  // Assume backend returns LlmAgentConfig with ToolDTO[] for tools
  const { data } = await apiClient.get<LlmAgentConfig>(`/agents/${id}`);

  // Map ToolDTO[] from backend to UiToolDefinition[] for UI consumption if needed
  // UiToolDefinition extends ToolDTO and can add UI-specific fields like icon, category, or a 'type' for display
  const toolsForUi: SharedUiToolDefinition[] = (data.tools || []).map((toolDto: ToolDTO) => ({
    ...toolDto,
    // Example: Add a UI-specific 'displayType' or ensure UiToolDefinition structure is met
    // For now, we assume UiToolDefinition might just be ToolDTO or have optional UI fields
    // If UiToolDefinition has mandatory fields not in ToolDTO, this mapping needs adjustment.
    // The current UiToolDefinition in @/types/tools just adds optional icon/category.
  }));

  return {
    ...data,
    tools: toolsForUi, // LlmAgentConfig expects ToolDTO[], but if UI needs UiToolDefinition, this should be UiAgent
                      // For now, let's assume LlmAgentConfig is used and tools are ToolDTO or compatible UiToolDefinition
  };
};

/**
 * Creates a new agent with the given configuration.
 */
export const createAgent = async (
  // Payload from form/UI likely uses UiToolDefinition for tools
  agentData: Omit<LlmAgentConfig, 'id' | 'created_at' | 'updated_at' | 'user_id' | 'tools'> & { tools?: SharedUiToolDefinition[], knowledgeBaseIds?: string[] },
): Promise<LlmAgentConfig> => {
  // Transform UiToolDefinition[] to ToolDTO[] for the API
  const toolsForApi: ToolDTO[] = (agentData.tools || []).map(uiTool => {
    const { icon, category, ...apiTool } = uiTool; // Exclude UI-specific fields
    return apiTool as ToolDTO; // Cast to ToolDTO
  });

  const apiPayload: CreateAgentAPIPayload = {
    ...agentData,
    tools: toolsForApi,
  };

  const { data } = await apiClient.post<LlmAgentConfig>('/agents', apiPayload);
  return data;
};

/**
 * Updates an existing agent's configuration.
 */
export const updateAgent = async (
  id: string,
  agentData: Partial<Omit<LlmAgentConfig, 'id' | 'created_at' | 'updated_at' | 'user_id' | 'tools'>> & { tools?: Partial<SharedUiToolDefinition>[], knowledgeBaseIds?: string[] },
): Promise<LlmAgentConfig> => {
  let toolsForApi: ToolDTO[] | undefined = undefined;
  if (agentData.tools) {
    toolsForApi = agentData.tools.map(uiTool => {
      const { icon, category, ...apiTool } = uiTool as SharedUiToolDefinition; // Cast to ensure UI fields are known
      return apiTool as ToolDTO; // What remains should be compatible with ToolDTO
    });
  }

  const apiPayload: UpdateAgentAPIPayload = {
    ...agentData,
    tools: toolsForApi, // Will be undefined if not in agentData, or ToolDTO[]
  };

  // Remove tools from payload if it's undefined, to avoid sending {tools: undefined}
  if (apiPayload.tools === undefined) {
    delete apiPayload.tools;
  }

  const { data } = await apiClient.patch<LlmAgentConfig>(`/agents/${id}`, apiPayload);
  return data;
};

export const deleteAgent = async (id: string): Promise<void> => {
  await apiClient.delete(`/agents/${id}`)
}

/**
 * Associates a tool with an agent.
 */
export const associateToolWithAgent = async (
  agentId: string,
  toolId: string,
): Promise<any> => { // The backend returns a Dict[str, Any] which can be { message: string, association: object }
  const { data } = await apiClient.post(`/agents/${agentId}/tools/${toolId}`);
  return data;
};

/**
 * Disassociates a tool from an agent.
 */
export const disassociateToolFromAgent = async (
  agentId: string,
  toolId: string,
): Promise<any> => { // The backend returns a Dict[str, str] which can be { message: string }
  const { data } = await apiClient.delete(`/agents/${agentId}/tools/${toolId}`);
  return data;
};

/**
 * Fetches all tools associated with a specific agent.
 */
export const getAgentTools = async (agentId: string): Promise<ToolDTO[]> => {
  const { data } = await apiClient.get<ToolDTO[]>(`/agents/${agentId}/tools`);
  return data;
};

export default {
  fetchAgents,
  fetchAgentById,
  createAgent,
  updateAgent,
  deleteAgent,
  associateToolWithAgent, // Added
  disassociateToolFromAgent, // Added
  getAgentTools, // Added
};
